<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>In action on 一只菜鸡的成长之路</title>
    <link>https://blog.scnace.me/tags/in-action/</link>
    <description>Recent content in In action on 一只菜鸡的成长之路</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>copyleft</copyright>
    <lastBuildDate>Sun, 25 Jun 2017 16:49:56 +0000</lastBuildDate>
    
	<atom:link href="https://blog.scnace.me/tags/in-action/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>那么就开始使用Context吧</title>
      <link>https://blog.scnace.me/post/head-to-context/</link>
      <pubDate>Sun, 25 Jun 2017 16:49:56 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/head-to-context/</guid>
      <description>Context并不是银弹,使用时需注意其使用场景。 Context golang的context包的&amp;rdquo;前身&amp;rdquo;来自golang.org</description>
    </item>
    
    <item>
      <title>golang bufio实验</title>
      <link>https://blog.scnace.me/post/golang-bufio%E5%AE%9E%E9%AA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/golang-bufio%E5%AE%9E%E9%AA%8C/</guid>
      <description>Who is he? 好了 开始今天的包 嗯 今天的包的名字是bufio . 他呢 就是证明golang不单单是脚本语言的证据! 他实现了缓冲 I/O 他包含了io.Reader</description>
    </item>
    
    <item>
      <title>golang channel实验</title>
      <link>https://blog.scnace.me/post/golang-channel%E5%AE%9E%E9%AA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/golang-channel%E5%AE%9E%E9%AA%8C/</guid>
      <description>信道(channel)是Goroutine之间通信的手段,所以,掌握Channel的用法之于Golang的学习变得尤为重要。 信道到底是怎么一</description>
    </item>
    
    <item>
      <title>golang panic和recover实验小结</title>
      <link>https://blog.scnace.me/post/golang-panic%E5%92%8Crecover%E5%AE%9E%E9%AA%8C%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/golang-panic%E5%92%8Crecover%E5%AE%9E%E9%AA%8C%E5%B0%8F%E7%BB%93/</guid>
      <description>认识Panic和Recover Panic 这是Golang中的一个内建函数，可以中断原有的控制流程，进入一个令人恐慌的流程中。当函数F调用Panic，</description>
    </item>
    
    <item>
      <title>golang 闭包实践</title>
      <link>https://blog.scnace.me/post/golang-%E9%97%AD%E5%8C%85%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/golang-%E9%97%AD%E5%8C%85%E5%AE%9E%E8%B7%B5/</guid>
      <description>Problem 前几天在 知乎 上看到了一个很好的问题 回答中也有很多干货 于是 我也想加深一下对闭包的理解 于是 写下了这篇部落格。 Description 作用域(scopes) 作用域,它</description>
    </item>
    
    <item>
      <title>golang多返回值写法</title>
      <link>https://blog.scnace.me/post/golang%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E5%86%99%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/golang%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC%E5%86%99%E6%B3%95/</guid>
      <description>看热闹不嫌事大系列&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;如何看待函数返回多个值的设计? From 知乎 这个号称是Golang特性之一的 多返</description>
    </item>
    
    <item>
      <title>golang常用数据结构</title>
      <link>https://blog.scnace.me/post/golang%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/golang%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>原post:RUSS Cox Blog Go Data Structure 一些常用数据格式如下所示: 图解： i在memory中表示一个32 bits的数据,也就是4 bytes的数据。也就是</description>
    </item>
    
    <item>
      <title>golang结构体和json之间的转换小结</title>
      <link>https://blog.scnace.me/post/golang%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8Cjson%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%B0%8F%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/golang%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8Cjson%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%B0%8F%E7%BB%93/</guid>
      <description>golang提供了结构体到特定格式json/xml/&amp;hellip; 转换的便捷途径 我们通过json包 很方便的就可以进行struct到json</description>
    </item>
    
    <item>
      <title>一次爬方正教务处的成功实践(第二弹)----jwcconn的第一次Release</title>
      <link>https://blog.scnace.me/post/%E4%B8%80%E6%AC%A1%E7%88%AC%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E5%A4%84%E7%9A%84%E6%88%90%E5%8A%9F%E4%BA%8B%E4%BB%B6%E4%B8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/%E4%B8%80%E6%AC%A1%E7%88%AC%E6%AD%A3%E6%96%B9%E6%95%99%E5%8A%A1%E5%A4%84%E7%9A%84%E6%88%90%E5%8A%9F%E4%BA%8B%E4%BB%B6%E4%B8%8B/</guid>
      <description>前情回顾: 之前的一次爬教务处的成功实践里面记录了一些在爬教务处时需要注意的点。并PO出了一份Beego写的教务处的API版本.但是由于没有前</description>
    </item>
    
    <item>
      <title>从遍历DOM树谈BFS和DFS</title>
      <link>https://blog.scnace.me/post/%E4%BB%8E%E9%81%8D%E5%8E%86dom%E6%A0%91%E8%B0%88dfs%E5%92%8Cbfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/%E4%BB%8E%E9%81%8D%E5%8E%86dom%E6%A0%91%E8%B0%88dfs%E5%92%8Cbfs/</guid>
      <description>工作点滴(闲谈) 这是工作点滴目录下的第一篇文章,上班确实累,老大其实也没怎么带我,就说了几个需求,让我自己去完成,最后完成帮我做次Code/</description>
    </item>
    
    <item>
      <title>关于JSON的思索</title>
      <link>https://blog.scnace.me/post/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%89%8D%E6%98%AF%E5%90%88%E6%B3%95json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%89%8D%E6%98%AF%E5%90%88%E6%B3%95json/</guid>
      <description>JavaScript Object Notation 简述 JSON是这几年一下子火爆起来的数据交换格式,在前后端的交互中,JSON也似乎变成了一门必修课,相比之下,反而像XML之类的格式在</description>
    </item>
    
    <item>
      <title>关于golang的延后执行defer</title>
      <link>https://blog.scnace.me/post/%E5%85%B3%E4%BA%8Egolang%E7%9A%84%E5%BB%B6%E5%90%8E%E6%89%A7%E8%A1%8Cdefer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/%E5%85%B3%E4%BA%8Egolang%E7%9A%84%E5%BB%B6%E5%90%8E%E6%89%A7%E8%A1%8Cdefer/</guid>
      <description>defer:在函数执行到最后时,再进行调用声明了defer的函数。 DEMO： package main import ( &amp;quot;fmt&amp;quot; ) func defer_first(){ fmt.Println(&amp;quot;Hi ! I&#39;m first defer&amp;quot;); } func dataOp(data1 float32 ,data2 float32)(float32,float32){ return data1+data2,data1*data2 } //只有一个defe</description>
    </item>
    
    <item>
      <title>关于代理池</title>
      <link>https://blog.scnace.me/post/%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%90%86%E6%B1%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%90%86%E6%B1%A0/</guid>
      <description>写在前面 在很多个爬虫死于非命之后,果然不出所料,接到了新的需求:新增代理池.其实也不用说,在Web站点和爬虫的斗争中,爬虫太容易就可以伪装自</description>
    </item>
    
    <item>
      <title>用CookieJar获取一次302/301跳转的Cookie</title>
      <link>https://blog.scnace.me/post/%E7%94%A8cookiejar%E6%8B%A6%E6%88%AA%E4%B8%80%E6%AC%A1302%E8%B7%B3%E8%BD%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://blog.scnace.me/post/%E7%94%A8cookiejar%E6%8B%A6%E6%88%AA%E4%B8%80%E6%AC%A1302%E8%B7%B3%E8%BD%AC/</guid>
      <description>问题描述: 在遇到需要登录的场景下,往往需要一次302/301跳转,然而我们的Client会跟着一起跳转,这时如果获取response.Coo</description>
    </item>
    
  </channel>
</rss>